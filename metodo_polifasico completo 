import java.util.*;

public class metodo_polifasico {


    public static List<List<Integer>> generarRuns(List<Integer> datos, int tamBloque) {
        List<List<Integer>> runs = new ArrayList<>();
        for (int i = 0; i < datos.size(); i += tamBloque) {
            int fin = Math.min(i + tamBloque, datos.size());
            List<Integer> bloque = new ArrayList<>(datos.subList(i, fin));
            Collections.sort(bloque); 
            runs.add(bloque);
        }
        return runs;
    }


    public static List<Integer> merge(List<Integer> a, List<Integer> b) {
        List<Integer> res = new ArrayList<>();
        int i = 0, j = 0;
        while (i < a.size() && j < b.size()) {
            if (a.get(i) <= b.get(j)) res.add(a.get(i++));
            else res.add(b.get(j++));
        }
        while (i < a.size()) res.add(a.get(i++));
        while (j < b.size()) res.add(b.get(j++));
        return res;
    }


    public static int[] distribucionFibonacci(int n) {
        List<Integer> fib = new ArrayList<>(Arrays.asList(1, 1));
        while (fib.get(fib.size() - 1) < n) {
            int size = fib.size();
            fib.add(fib.get(size - 1) + fib.get(size - 2));
        }
        int f1 = fib.get(fib.size() - 1);
        int f2 = fib.get(fib.size() - 2);
        return new int[]{f2, f1 - f2}; 
    }
public static void main(String[] args) {

        List<Integer> datos = Arrays.asList(23, 734, 178, 90, 2594, 1212, 5345, 747, 393, 536);
        System.out.println("Datos originales: " + datos);


        List<List<Integer>> runs = generarRuns(datos, 3);
        System.out.println("\nRuns iniciales:");
        for (List<Integer> run : runs) System.out.println(run);


        Queue<List<Integer>> A = new LinkedList<>();
        Queue<List<Integer>> B = new LinkedList<>();
        Queue<List<Integer>> C = new LinkedList<>();


        int[] dist = distribucionFibonacci(runs.size());
        for (int i = 0; i < runs.size(); i++) {
            if (i < dist[0]) A.add(runs.get(i));
            else B.add(runs.get(i));
        }

        System.out.println("\nDistribución inicial:");
        System.out.println("A: " + A);
        System.out.println("B: " + B);
        System.out.println("C: " + C);


        while (A.size() + B.size() + C.size() > 1) {

            Queue<List<Integer>> src1, src2, dest;
            if (A.isEmpty()) { src1 = B; src2 = C; dest = A; }
            else if (B.isEmpty()) { src1 = A; src2 = C; dest = B; }
            else { src1 = A; src2 = B; dest = C; }


            List<Integer> r1 = src1.poll();
            List<Integer> r2 = src2.poll();
            if (r1 != null && r2 != null) {
                List<Integer> merged = merge(r1, r2);
                dest.add(merged);
            } else if (r1 != null) dest.add(r1);
            else if (r2 != null) dest.add(r2);

            System.out.println("\nfusión:");
            System.out.println("A: " + A);
            System.out.println("B: " + B);
            System.out.println("C: " + C);
        }


        List<Integer> ordenado = new ArrayList<>();
        if (!A.isEmpty()) ordenado = A.poll();
        if (!B.isEmpty()) ordenado = B.poll();
        if (!C.isEmpty()) ordenado = C.poll();

        System.out.println("\nArchivo final ordenado: " + ordenado);
    }
}